#!/usr/bin/env python3
# test_vulnerability_manager.py

import sqlite3
import logging
from datetime import datetime
from db.schema import setup_database
from db.vulnerability_manager import VulnerabilityManager
from db.models import Vulnerability
import tempfile
import os

# Настройка логирования для тестов
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def test_vulnerability_manager_comprehensive():
    """
    Комплексное тестирование VulnerabilityManager
    """
    print("=" * 60)
    print("КОМПЛЕКСНОЕ ТЕСТИРОВАНИЕ VULNERABILITY MANAGER")
    print("=" * 60)
    
    # Создаем временную БД
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as tmp_file:
        db_path = tmp_file.name
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Инициализируем БД
        setup_database(cursor)
        conn.commit()
        
        # Создаем менеджер
        vuln_manager = VulnerabilityManager()
        
        print("\n1. Тестирование парсинга Nuclei данных...")
        test_nuclei_parsing(vuln_manager, cursor)
        conn.commit()
        
        # print("\n2. Тестирование парсинга Wapiti данных...")  # УДАЛЕНО: Wapiti больше не используется
        # test_wapiti_parsing(vuln_manager, cursor)
        conn.commit()
        
        print("\n3. Тестирование парсинга Nmap данных...")
        test_nmap_parsing(vuln_manager, cursor)
        conn.commit()
        
        print("\n4. Тестирование парсинга Gobuster данных...")
        test_gobuster_parsing(vuln_manager, cursor)
        conn.commit()
        
        print("\n5. Тестирование дедупликации...")
        test_deduplication(vuln_manager, cursor)
        conn.commit()
        
        print("\n6. Тестирование валидации...")
        test_validation(vuln_manager, cursor)
        conn.commit()
        
        print("\n7. Анализ результатов...")
        analyze_results(cursor)
        
        conn.close()
        
        print("\n" + "=" * 60)
        print("✅ ВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!")
        print("=" * 60)
        
    except Exception as e:
        print(f"❌ Ошибка в тестах: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # Удаляем временную БД
        try:
            os.unlink(db_path)
        except:
            pass

def test_nuclei_parsing(vuln_manager: VulnerabilityManager, cursor):
    """Тестирует парсинг данных Nuclei"""
    nuclei_data = [
        {
            'host': 'https://example.com',
            'info': {
                'name': 'SQL Injection in login form',
                'severity': 'High',
                'description': 'SQL injection vulnerability detected in login parameter',
                'cve': ['CVE-2023-1234']
            }
        },
        {
            'host': 'https://example.com/admin',
            'info': {
                'name': 'Cross-site scripting vulnerability',
                'severity': 'Medium',
                'description': 'XSS found in search parameter'
            }
        }
    ]
    
    stats = vuln_manager.process_and_save_vulnerabilities(
        raw_data=nuclei_data,
        scanner_name='nuclei',
        cursor=cursor,
        target_resource='https://example.com'
    )
    
    print(f"   Nuclei - Обработано: {stats.processed}, Сохранено: {stats.saved_new}")
    assert stats.processed == 2
    assert stats.saved_new == 2

# УДАЛЕНО: Wapiti больше не используется
# def test_wapiti_parsing(vuln_manager: VulnerabilityManager, cursor):
#     """Тестирует парсинг данных Wapiti"""
#     wapiti_data = {
#         'vulnerabilities': [
#             {
#                 'resource': 'https://example.com/files',
#                 'vulnerability_type': 'Path Traversal',
#                 'description': 'Directory traversal vulnerability in file parameter',
#                 'severity': 'Critical',
#                 'scanner': 'wapiti'
#             },
#             {
#                 'resource': 'https://example.com/login',
#                 'vulnerability_type': 'Default Credentials',
#                 'description': 'Default credentials admin:admin found',
#                 'severity': 'High',
#                 'scanner': 'wapiti'
#             }
#         ],
#         'target': 'https://example.com'
#     }
#     
#     stats = vuln_manager.process_and_save_vulnerabilities(
#         raw_data=wapiti_data,
#         scanner_name='wapiti',
#         cursor=cursor,
#         target_resource='https://example.com'
#     )
#     
#     print(f"   Wapiti - Обработано: {stats.processed}, Сохранено: {stats.saved_new}")
#     assert stats.processed == 2
#     assert stats.saved_new == 2

def test_nmap_parsing(vuln_manager: VulnerabilityManager, cursor):
    """Тестирует парсинг данных Nmap"""
    nmap_data = {
        'output': '''Starting Nmap scan...
        22/tcp   open  ssh     OpenSSH 7.4
        | vulners: 
        | CVE-2023-5678 7.5   CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N
        80/tcp   open  http    Apache httpd 2.4.6
        | vulners:
        | CVE-2023-9999 9.8   CRITICAL vulnerability in Apache
        ''',
        'target': '192.168.1.100',
        'scanner': 'nmap'
    }
    
    stats = vuln_manager.process_and_save_vulnerabilities(
        raw_data=nmap_data,
        scanner_name='nmap',
        cursor=cursor,
        target_resource='192.168.1.100'
    )
    
    print(f"   Nmap - Обработано: {stats.processed}, Сохранено: {stats.saved_new}")
    assert stats.processed >= 1  # Должен найти хотя бы одну уязвимость

def test_gobuster_parsing(vuln_manager: VulnerabilityManager, cursor):
    """Тестирует парсинг данных Gobuster"""
    gobuster_data = {
        'output': '''Starting gobuster...
        /admin                (Status: 200) [Size: 1234]
        /config               (Status: 403) [Size: 567]
        /backup               (Status: 301) [Size: 0] [--> /backup/]
        /test                 (Status: 200) [Size: 890]
        ''',
        'target': 'https://example.com',
        'scanner': 'gobuster'
    }
    
    stats = vuln_manager.process_and_save_vulnerabilities(
        raw_data=gobuster_data,
        scanner_name='gobuster',
        cursor=cursor,
        target_resource='https://example.com'
    )
    
    print(f"   Gobuster - Обработано: {stats.processed}, Сохранено: {stats.saved_new}")
    assert stats.processed >= 3  # Должен найти директории

def test_deduplication(vuln_manager: VulnerabilityManager, cursor):
    """Тестирует дедупликацию"""
    # Повторно добавляем те же данные Nuclei
    nuclei_data = [
        {
            'host': 'https://example.com',
            'info': {
                'name': 'SQL Injection in login form',
                'severity': 'High',
                'description': 'SQL injection vulnerability detected in login parameter'
            }
        }
    ]
    
    # Сбрасываем кэш сессии для чистого теста
    vuln_manager.reset_session_cache()
    
    stats = vuln_manager.process_and_save_vulnerabilities(
        raw_data=nuclei_data,
        scanner_name='nuclei',
        cursor=cursor,
        target_resource='https://example.com'
    )
    
    print(f"   Дедупликация - Обработано: {stats.processed}, Пропущено дубликатов: {stats.duplicates_skipped}")
    assert stats.duplicates_skipped > 0  # Должны быть найдены дубликаты

def test_validation(vuln_manager: VulnerabilityManager, cursor):
    """Тестирует валидацию данных"""
    # Тест с невалидными данными
    invalid_data = [
        {
            'host': '',  # Пустой ресурс
            'info': {
                'name': 'Test vulnerability',
                'severity': 'InvalidSeverity'  # Неправильная критичность
            }
        }
    ]
    
    stats = vuln_manager.process_and_save_vulnerabilities(
        raw_data=invalid_data,
        scanner_name='test',
        cursor=cursor
    )
    
    print(f"   Валидация - Ошибок валидации: {stats.validation_errors}")
    assert stats.validation_errors > 0  # Должны быть ошибки валидации

def analyze_results(cursor):
    """Анализирует итоговые результаты"""
    # Общая статистика
    cursor.execute("SELECT COUNT(*) FROM vulnerability")
    total_vulns = cursor.fetchone()[0]
    
    # По сканерам
    cursor.execute("SELECT scanner, COUNT(*) FROM vulnerability GROUP BY scanner")
    by_scanner = cursor.fetchall()
    
    # По критичности
    cursor.execute("""
        SELECT severity, COUNT(*) 
        FROM vulnerability 
        GROUP BY severity 
        ORDER BY CASE severity 
            WHEN 'Critical' THEN 1 
            WHEN 'High' THEN 2 
            WHEN 'Medium' THEN 3 
            WHEN 'Low' THEN 4 
            ELSE 5 
        END
    """)
    by_severity = cursor.fetchall()
    
    print(f"   Всего уязвимостей в БД: {total_vulns}")
    print("   По сканерам:")
    for scanner, count in by_scanner:
        print(f"     {scanner}: {count}")
    print("   По критичности:")
    for severity, count in by_severity:
        print(f"     {severity}: {count}")
    
    # Проверяем индексы
    cursor.execute("SELECT name FROM sqlite_master WHERE type='index' AND name LIKE 'idx_%'")
    indexes = cursor.fetchall()
    print(f"   Создано индексов: {len(indexes)}")

def test_performance():
    """Простой тест производительности"""
    print("\n" + "=" * 60)
    print("ТЕСТ ПРОИЗВОДИТЕЛЬНОСТИ")
    print("=" * 60)
    
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as tmp_file:
        db_path = tmp_file.name
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Инициализируем БД
        setup_database(cursor)
        conn.commit()
        
        vuln_manager = VulnerabilityManager()
        
        # Генерируем большое количество тестовых данных
        start_time = datetime.now()
        
        for i in range(100):
            test_data = [
                {
                    'host': f'https://example{i}.com',
                    'info': {
                        'name': f'Test vulnerability {i}',
                        'severity': 'Medium',
                        'description': f'Test description {i}'
                    }
                }
            ]
            
            vuln_manager.process_and_save_vulnerabilities(
                raw_data=test_data,
                scanner_name='performance_test',
                cursor=cursor,
                target_resource=f'https://example{i}.com'
            )
            
            if i % 20 == 0:
                conn.commit()
        
        conn.commit()
        end_time = datetime.now()
        
        duration = (end_time - start_time).total_seconds()
        print(f"Обработка 100 уязвимостей заняла: {duration:.2f} секунд")
        print(f"Производительность: {100/duration:.1f} уязвимостей/сек")
        
        # Проверяем финальное количество
        cursor.execute("SELECT COUNT(*) FROM vulnerability WHERE scanner = 'performance_test'")
        count = cursor.fetchone()[0]
        print(f"Сохранено уязвимостей: {count}")
        
        conn.close()
        
    except Exception as e:
        print(f"❌ Ошибка в тесте производительности: {e}")
    finally:
        try:
            os.unlink(db_path)
        except:
            pass

if __name__ == "__main__":
    # Запускаем комплексные тесты
    test_vulnerability_manager_comprehensive()
    
    # Запускаем тест производительности
    test_performance()
    
    print("\n🎉 ТЕСТИРОВАНИЕ ЗАВЕРШЕНО!")
